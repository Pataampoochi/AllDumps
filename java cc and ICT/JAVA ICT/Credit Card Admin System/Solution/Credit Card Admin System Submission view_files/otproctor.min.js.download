/**
* Enabling proctoring abilities
* @class OTProctor
*/
function OTProctor() {
  const STUDENT = 'STUDENT';
  const PROCTOR = 'PROCTOR';

  const LOG_LEVEL = {
    ERROR: 0,
    INFO: 1,
    DEBUG: 2,
    VERBOSE: 3 //printing everything to console too
  };

  let logContent = [];
  let currLogLevel = LOG_LEVEL.DEBUG;

  const Logger = (level, message)=> {
    if (level<=currLogLevel) {
      logContent.push(
        {
          time: new Date(),
          lvl: level,
          msg: message
        }
      );
    }
    if (currLogLevel === LOG_LEVEL.VERBOSE) {
      console.log(message);
    }
  }

  const setLogLevel = (level) => {
    switch (level) {
      case 0:
        currLogLevel = LOG_LEVEL.ERROR;
        break;
      case 1:
        currLogLevel = LOG_LEVEL.INFO;
        break;
      case 2:
        currLogLevel = LOG_LEVEL.DEBUG;
        break;
      default:
        currLogLevel = LOG_LEVEL.VERBOSE;
        break;
    }
  };

  const STATE = {
    STARTABLE: 'STARTABLE',
    STOPPABLE: 'STOPPABLE',
    STARTING: 'STARTING',
    PLAYING: 'PLAYING',
    LIVE: 'LIVE',
    SEEKING: 'SEEKING'
  };

  let currUserType = STUDENT;
  let currState = null;
  let ws = null;
  this.ws = ws;
  let webRtcPeer = null;
  let socketPingIntervalRef = null;
  let idleTimeout = 55000; //when server automatically closes connection
  let snapshotIntervalRef = null;
  let snapshotMediastreamRef = null;
  let SOCKET_URL = null;
  let API_URL = null;
  let startRecordingSuccessCallback = null;
  let startRecordingDisconnectCallback = null;
  let videoStreamSuccessCallback = null;
  let recordedStreamEndCallback = null;
  let seekAckSuccessCallback = null;
  let recordedPlayErrorCallback = null;
  let seekErrorCallback = null;
  let pauseAckSuccessCallback = null;
  let pauseErrorCallback = null;
  let resumeAckSuccessCallback = null;
  let resumeErrorCallback = null;
  let livePlayErrorCallback = null;

  let mediaPrefix = 'coursetimer_' + 'deviceID' + "_";
  let videodeviceID = localStorage.getItem(mediaPrefix + "video");
  let audiodeviceID = localStorage.getItem(mediaPrefix + "audio");

  let currUser = {
    type: STUDENT,
    userId : null,
    testId : null,
    token : null
  };
  let turnClient = 'OTTL';
  let turnServers = [];

  let startResponse = function startResponse(message) {
  	setState(STATE.STOPPABLE);
  	Logger(LOG_LEVEL.INFO,'SDP answer received from server. Processing ...');
  	webRtcPeer.processAnswer(message.sdpAnswer);
  }

  let onWebSocketMessage = function onWebSocketMessage(message) {
    let parsedMessage = JSON.parse(message.data);
  	Logger(LOG_LEVEL.INFO, 'Received message: ' + message.data);

  	switch (parsedMessage.id) {

      case 'startResponse':
    		startResponse(parsedMessage);
    		break;

      case 'endOfPlayback':
        Logger(LOG_LEVEL.INFO,'endOfPlayback');
        if (recordedStreamEndCallback) {
          recordedStreamEndCallback();
          recordedStreamEndCallback = null;
        }
        break;

      case 'disconnect':
        switch (parsedMessage.type) {
          case 'start':
            if (startRecordingDisconnectCallback) {
              startRecordingDisconnectCallback();
              startRecordingDisconnectCallback = null;
            }
            Logger(LOG_LEVEL.INFO, 'Recording stopped: disconnect');
            break;
          case 'live':
            Logger(LOG_LEVEL.INFO, 'Live play disconnect');
            break;
          default:
            Logger(LOG_LEVEL.INFO, 'Disconnect in stream');
          break;
        }
        break;

      case 'recordingStarted':
        if (parsedMessage.type === 'start') {
          if (startRecordingSuccessCallback) {
            startRecordingSuccessCallback();
            startRecordingSuccessCallback = null;
          }
          Logger(LOG_LEVEL.INFO, 'Recording started');
        }
        break;

      case 'error':
    		if (currState === STATE.STARTING) {
    			setState(STATE.STARTABLE);
    		}
        switch (parsedMessage.type) {
            case 'start':
              //error callback for recording start
              if (startRecordingErrorCallback) {
                startErrorCallback();
                startErrorCallback = null;
              }
              break;
            case 'onIceCandidate':

              break;
            case 'stop':
              //error callback for recording stop
              if (stopRecordingErrorCallback) {
                stopRecordingErrorCallback();
                stopRecordingErrorCallback = null;
              }
              break;
            case 'play':
              //error callback for playing recorded video start
              if (recordedPlayErrorCallback) {
                recordedPlayErrorCallback();
                recordedPlayErrorCallback = null;
              }
              break;
            case 'live':
              //error callback for playing live video
              if (livePlayErrorCallback) {
                livePlayErrorCallback();
                livePlayErrorCallback = null;
              }
              break;
            case 'seek':
              //error callback for seeking on a recorded video
              if (seekErrorCallback) {
                seekErrorCallback();
                seekErrorCallback = null;
              }
              break;
            case 'pause':
              //error callback for pausing a recorded video
              if (pauseErrorCallback) {
                pauseErrorCallback();
                pauseErrorCallback = null;
              }
              break;
            case 'resume':
              //error callback for resuming a recorded video
              if (resumeErrorCallback) {
                resumeErrorCallback();
                resumeErrorCallback = null;
              }
              break;
          default:

        }
    		onError('Error message from server: ' + parsedMessage.message);
    		break;

      case 'iceCandidate':
    		webRtcPeer.addIceCandidate(parsedMessage.candidate);
    		break;
      case 'liveStarted':
        if (parsedMessage.type === 'live') {
          Logger(LOG_LEVEL.INFO,'live stream started');
          if (videoStreamSuccessCallback) {
            videoStreamSuccessCallback();
            videoStreamSuccessCallback = null;
          }
        }
      break;
      case 'playStarted':
        if (parsedMessage.type === 'live') {
          Logger(LOG_LEVEL.INFO,'live stream started');
          if (videoStreamSuccessCallback) {
            videoStreamSuccessCallback();
            videoStreamSuccessCallback = null;
          }
        } else if (parsedMessage.type === 'play') {
          Logger(LOG_LEVEL.INFO,'recorded stream started');
          if (videoStreamSuccessCallback) {
            videoStreamSuccessCallback();
            videoStreamSuccessCallback = null;
          }
        }
      break;
      case 'seekAck':
        //when seek completes;
        if (seekAckSuccessCallback) {
          seekAckSuccessCallback();
          seekAckSuccessCallback = null;
        }
      break;
      case 'pauseAck':
        //when pause completes;
        if (pauseAckSuccessCallback) {
          pauseAckSuccessCallback();
          pauseAckSuccessCallback = null;
        }
      break;

      case 'resumeAck':
        //when resume completes;
        if (resumeAckSuccessCallback) {
          resumeAckSuccessCallback();
          resumeAckSuccessCallback = null;
        }
      break;

      default:
    		if (currState == STATE.STARTING) {
    			setState(STATE.STARTABLE);
    		}
    		onError('Unrecognized message', parsedMessage);
      break;
    }
  };

  let onError = function onError(error) {
    Logger(LOG_LEVEL.INFO,'onError called...');
    Logger(LOG_LEVEL.ERROR,error);
    let errMsg = error.message;
    switch (error.name) {
      case 'NotAllowedError':
        if (errMsg.indexOf("The request is not allowed by the user agent") !=-1) {
          alert("Please allow camera/mic access to start")
        } else if (errMsg.indexOf("Permission denied")!=-1) {
          alert("Please allow camera/mic access to start")
        }
        else {
          console.error('Some other error', error.message);
        }
        break;
      default:
    }
    Logger(LOG_LEVEL.ERROR, JSON.stringify(error));
  };

  let sendMessage = function sendMessage(message) {
  	var jsonMessage = JSON.stringify(message);
  	Logger(LOG_LEVEL.INFO,'Sending message: ' + jsonMessage);
  	ws.send(jsonMessage);
  };

  let onOfferStartRecording = function onOfferStartRecording(error, offerSdp) {
  	if(error) return onError(error);

    Logger(LOG_LEVEL.INFO, 'Invoking SDP offer callback function ' + location.host);

    var message = {
  		id : 'start',
      sdpOffer : offerSdp,
      userId: currUser.userId,
      testId: currUser.testId,
      token: currUser.token
  	};

    sendMessage(message);
  };

  let setState = function setState(nextState) {
    currState = nextState;
  }

  let onIceCandidate = function onIceCandidate(candidate) {
  	   Logger(LOG_LEVEL.DEBUG,'Local candidate' + JSON.stringify(candidate));
  	   var message = {
  	      id : 'onIceCandidate',
  	      candidate : candidate
  	   };
  	   sendMessage(message);
  }
  let self = this;

  /***
   * Creates the sokcet connection if socket does not exist
   */
  function checkSocketPipe(action) {
    return new Promise(function(resolve, reject) {
      if (!ws || ws.readyState!=1) {
        Logger(LOG_LEVEL.DEBUG, 'Socket was closed, reopening '+action)
        ws = new WebSocket(SOCKET_URL);
        ws.onmessage = onWebSocketMessage;
        ws.onerror = function (error) {
          Logger(LOG_LEVEL.ERROR,'WebSocket Error ' + error);
          return reject(error);
        };
        ws.onopen = () => {
          Logger(LOG_LEVEL.DEBUG, 'SOCKET is open..'+action)
          self.ws = ws;
          socketPingIntervalRef = setInterval(
            function () {
              sendMessage({
                id: 'ping',
                // time: `${new Date()}`
              });
          },idleTimeout);
          resolve(true);
        }
        ws.onclose = (ev) => {
          if (socketPingIntervalRef) {
            window.clearInterval(socketPingIntervalRef);
            Logger(LOG_LEVEL.INFO, 'cleared interval');
          }

          Logger(LOG_LEVEL.DEBUG, 'SOCKET is closing..'+action)
          Logger(LOG_LEVEL.DEBUG ,ev);
        }
      } else {
         resolve(true);
      }
    });
  }

  /**
   * @private
   * @memberOf OTProctor
   * @description fetch credentials for turn server
   * */
  fetchTurnCred = (uid, tid, pid, tkn, client, turnIP )=>{
    return new Promise(function(resolve, reject) {
      Logger(LOG_LEVEL.INFO,'fetchTurnCred called');

      if (currUserType !== STUDENT && !pid ) {
        //if proctor then proctorid can not be null
        return rejects(false);
      }

      if (!uid || !tid || !tkn) {
        return reject(false);
      }

      if (!client) {
        client = 'teknoturf';
      }

      var requestParams = {
        'client': client,
        'userid': uid,
        'testid': tid,
      };

      if(pid != "" && pid && pid !=0 ){
        requestParams['proctorid'] = pid
      }

      fetch(`${API_URL}/api/turncred`, {
        method: 'post',
        headers: {
          'Accept': 'application/json, text/plain, */*',
          'Content-Type': 'application/json',
          'Authorization': 'Bearer '+tkn
        },
        body: JSON.stringify(requestParams)
      })
      .then((data)=>{
        if (data.status === 200) {
          let res = data.json();
          res.then((resdata)=>{
            Logger(LOG_LEVEL.INFO, 'fetchTurnCred success.');
            Logger(LOG_LEVEL.DEBUG, JSON.stringify(resdata));
            if (resdata && resdata.username && resdata.password) {
              return resolve({
                username: resdata.username,
                credential: resdata.password
              });
            } else {
              return reject();
            }});
        } else {
          Logger(LOG_LEVEL.INFO, 'fetchTurnCred failed')
          Logger(LOG_LEVEL.DEBUG, `${data.status} ${data.statusText}` )
          reject(data.statusText)
        }
      })
      .catch((err)=>{
        //cant send to backend
        Logger(LOG_LEVEL.ERROR, 'Unable to fetch turncred' + err)
        reject(false);
      });
    });
  };

  getTurnWithAuth = (turnDetailArray, cred) => {
    let authenticatedTurnArray = turnDetailArray.map((turnEntry) => {
      //check if its stun or turn. right now only turn requires credentials
      if (turnEntry.url && turnEntry.url.indexOf('turn:')==0) {

        if (!turnEntry.username) {
          turnEntry.username = cred.username;
        }

        if (!turnEntry.credential) {
          turnEntry.credential = cred.credential;
        }
      }
      return turnEntry; //return even if it is STUN
    });
    return authenticatedTurnArray;
  }
  /**
   * @typedef TurnDetail
   * @property {string} uri The turn url
   * @property {string} [username] username, defaults to latest username received from /turncred
   * @property {string} [credential] password, defaults to latest password received from /turncred
   *
   * @example
   *  {
   *    "url": "turn:x.y.z.44:12ab",
   +    "username": "usernamexxx",
   +    "credential": "passwordxxx"
   +  }
   */

  /**
   * @public
   * @instance
   * @memberOf OTProctor
   * @method initialize
   * @description initialize OTProctor object
   * @param {string} type - STUDENT, PROCTOR
   * @param {string} uid - User Id - for student or proctor
   * @param {string} tid - Test Id - current test id
   * @param {string} token - TT Auth token to be passed in susbsequent requrests
   * @param {string} WSURL - The websocket URL with scheme and endpoint eg wss://12.12.12.12:899/proctor
   * @param {string} APIURL - REST API base url with scheme eg https://12.12.12.12:9000
   * @param {Array<TurnDetail>} TURNDetail - TURN Server details eg url:turn:3.7.111.44:8787, username, credential
   * @param {string} TURNClient - Username for the turn client
   * @param {number} [connectionTimeout=55] - time in seconds after which to ping proctor backend, to keep connection open at ALB
   * @param {number} [loglevel=2] - 0 for ERROR, 1 for INFO, 2 for DEBUG, default to DEBUG
   *
   * @returns {boolean} Returns false if mandatory params are missing, true otherwise
   *
   * @example
   *  let otproc = new OTProctor();
   *  otproc
   * .initialize('STUDENT', 1, 1, '1sadfwe', 'wss://12.12.12.12:899/proctor','https://123.123.123.12:9000', [], 2)
   *
   */
  this.initialize = (type, uid, tid, token, WSURL, APIURL, TURNDetail, TURNClient, connectionTimeout, loglevel) => {

    if (!kurentoUtils) {
      //required library not found
      Logger(LOG_LEVEL.ERROR, 'kurentoUtils library not found. initialize FAILED.')
      return false;
    }

    if (!type) {
      Logger(LOG_LEVEL.ERROR, "Type is missing")
      return false;
    }

    if (uid==null || !token || !WSURL || !APIURL) {
      Logger(LOG_LEVEL.DEBUG, "Insufficient args, pleas provide." + uid + ' '+ tid +' '+' '+ token + ' '+ WSURL + ' '+ APIURL);
      Logger(LOG_LEVEL.ERROR, "Insufficient args ")
      return false;
    }

    if (TURNDetail) {
      turnServers = TURNDetail;
    }

    if (TURNClient) {
      turnClient = TURNClient;
    }

    if (connectionTimeout) {
      idleTimeout = connectionTimeout*1000;
    }
    SOCKET_URL = WSURL;
    API_URL = APIURL;

    switch (type) {
      case STUDENT:
        currUserType = STUDENT;
        currUser.type = STUDENT;
        currUser.userId = uid;
        currUser.testId = tid;
        currUser.token = token;
        break;
      case PROCTOR:
        currUserType = PROCTOR;
        currUser.type = PROCTOR;
        currUser.userId = uid;//change to proctor id
        currUser.testId = tid;
        currUser.token = token;
        break;
      default:
        break;
    }

    if (loglevel) {
      setLogLevel(loglevel);
    } else {
      setLogLevel(2);
    }
    return true;
  };

  /**
   * @public
   * @instance
   * @memberOf OTProctor
   * @method startRecording
   * @description starts recording the video stream
   * @param {string} videoElementId - HTML ID for the element
   * @param {function} successCallback - callback function to be fired on success
   * @param {function} disconnectCallback - callback function to be called when disconnect happens
   *
   * @returns {Promise} - Resolves to true if socket is open and invokes startRecording, false if error in creating socket
   *
   * @example
   *    otproc.startRecording()
   */
  this.startRecording = (videoElementId, successCallback, disconnectCallback) => {
    return new Promise(function(resolve, reject) {
      checkSocketPipe('start_recording')
      .then((data)=>{
        return fetchTurnCred(currUser.userId, currUser.testId, null, currUser.token, turnClient, null)
      })
      .then((turnCred)=>{
        _startRecording(turnCred, videoElementId, successCallback, disconnectCallback);
        resolve(true);
      })
      .catch((err)=>{
        reject(err);
      })
    });
  };

  _startRecording = (turnCred,videoElementId, successCallback, disconnectCallback) => {
    Logger(LOG_LEVEL.DEBUG,'startRecording called..');
    let videoInput = document.getElementById(videoElementId);
    setState(STATE.STARTING);
    Logger(LOG_LEVEL.DEBUG,'starting recording and generating local sdp offer');
    let turnServersWithAuth = getTurnWithAuth(turnServers, turnCred);
    let options = {
      localVideo: videoInput,
      onicecandidate : onIceCandidate,
    };
    // if turnServers is null then use freeice
    if (turnServersWithAuth) {
      options.configuration = {
        iceServers: turnServersWithAuth
      }
    }

    let constraints = {
      audio: {
        deviceId: { 
          exact: audiodeviceID 
        }
      },
      video: {
        deviceId: { 
          exact: videodeviceID 
        },
        width: {
          min: 320,
          ideal: 640,
          max: 1280
        }
      }
    };
    options.mediaConstraints = constraints;
    Logger(LOG_LEVEL.DEBUG, options);

    webRtcPeer = kurentoUtils.WebRtcPeer.WebRtcPeerSendonly(options, function(error) {
        if(error) {
          if(disconnectCallback) disconnectCallback();
          return onError(error);
        } else {
          startRecordingSuccessCallback = successCallback;
          startRecordingDisconnectCallback = disconnectCallback;
          this.generateOffer(onOfferStartRecording);
        }
    });
  };

  /**
   * @public
   * @instance
   * @memberOf OTProctor
   * @method stopRecording
   * @description Stops the recording and closes vidoe & microphone
   * @param {function} [successCallback] - invoked when recording is stopped
   *
   * @returns {Promise} - Resolves to true if able to open socket and invoke stopRecording, false if error in creating socket
   */
  this.stopRecording = (successCallback) => {
    return new Promise(function(resolve, reject) {
      checkSocketPipe('stop_recording')
      .then(()=>{
        _stopRecording(currUser.token, successCallback);
        resolve(true);
      })
      .catch((err)=>{
        reject(err);
      });
    });
  };

  _stopRecording = (token, successCallback)=>{
    Logger(LOG_LEVEL.INFO, 'Stopping Recording..'+successCallback)
  	setState(STATE.STARTABLE);
  	if (webRtcPeer) {
  		webRtcPeer.dispose();
  		webRtcPeer = null;
  		var message = {
  			id : 'stop',
        token: token
  		}
  		sendMessage(message);
      ws.close();
      if(successCallback) successCallback();
  	}
  };

  /**
   * @public
   * @instance
   * @memberOf OTProctor
   * @method startPeriodicSnapshot
   * @description starts taking webcam snapshots on regular interval and send it to backend
   * @param {number} [interval=5] - interval in seconds after which snapshot should be triggered
   * @param {number} [snapwidth=320] - width of the snapshot to be captured in pixels
   * @param {string} [sid=currUser.userId] - userid for the student, defaults to the userid set in initialize if passed null
   * @param {string} [tid=currUser.testId] - testId for the current session, defaults to the testid set in initialize if passed null
   * @param {string} [tkn=currUser.token] - token for the current session, defaults to the token set in initialize if passed null
   *
   * @returns {Promise} A promise object that resolves to setInterval reference or rejects with error
   *
   */
  this.startPeriodicSnapshot = (interval, snapwidth, sid, tid, tkn) => {
    Logger(LOG_LEVEL.INFO, 'SendSnapshot called');
    let intervalDuration = interval ? interval*1000 : 5000;
    let width = snapwidth ? snapwidth : 320;

    let studentId = sid ? sid: currUser.userId;
    let testId= tid ? tid: currUser.testId;
    let token = tkn ? tkn: currUser.token;

    let height = 0;
    let streaming = false;
    let video = document.createElement('video');
    let canvas = document.createElement('canvas');

    return new Promise((resolve, reject)=>{
      if (snapshotIntervalRef) {
        self.stopPeriodicSnapshot();
      }
      navigator.mediaDevices.getUserMedia({audio:false, video: {
        deviceId: { 
          exact: videodeviceID 
        },
        width: {
          min: 320,
          ideal: width,
          max: 1280
        }
      }})
      .then(function(stream) {
          snapshotMediastreamRef = stream;
          video.srcObject = stream;
          video.play();
          video.addEventListener('canplay', function(ev){
            Logger(LOG_LEVEL.INFO,'canplay called...');
            if (!streaming) {
              height = video.videoHeight / (video.videoWidth/width);
              video.setAttribute('width', width);
              video.setAttribute('height', height);
              canvas.setAttribute('width', width);
              canvas.setAttribute('height', height);
              streaming = true;
              captureUserimageAndSave(studentId, testId, token);
              snapshotIntervalRef = setInterval(
                function () {
                  navigator.mediaDevices.getUserMedia({audio:false, video: {
                    deviceId: { 
                      exact: videodeviceID 
                    }
                  }})
                  .then(function(stream) {
                    //webcam is on, snapshot can be captured.
                    captureUserimageAndSave(studentId, testId, token);
                  })
                  .catch(function(err) {
                    console.log('snapshot blocked as webcam is off');
                  });
                },
              intervalDuration);
              resolve(snapshotIntervalRef);
            }
          }, false);
      })
      .catch(function(err) {
          Logger(LOG_LEVEL.ERROR,"An error occurred: " + err);
          reject(err)
      });

        function captureUserimageAndSave(studentId, testId, token) {
          let picture = grabFrame();
          clearCanvas();
          if (picture) {
              sendSnapshotToBackend(studentId, testId, token, picture)
                  .then((stored) => {
                      Logger(LOG_LEVEL.INFO, 'stored. snapshot');
                  })
                  .catch((err) => {
                      Logger(LOG_LEVEL.DEBUG, 'SendSnapshot failed');
                      Logger(LOG_LEVEL.ERROR, err);
                  });
          }
          var storagePrefix = 'coursetimer_' + testId + "_" + studentId + "_";
          // currentTime = Math.round(new Date().getTime()/1000);
          var currentTime = localStorage.getItem(storagePrefix + "currentTime")
          localStorage.setItem(storagePrefix + "lastImageCaptureTime", currentTime);
        }

      function clearCanvas() {
        var context = canvas.getContext('2d');
        context.fillStyle = "#AAA";
        context.fillRect(0, 0, canvas.width, canvas.height);
        var data = canvas.toDataURL('image/jpeg',  0.3);
      }

      function grabFrame() {
        Logger(LOG_LEVEL.INFO,'grabframe calledd....');
        var context = canvas.getContext('2d');
        if (width && height) {
          canvas.width = width;
          canvas.height = height;
          context.drawImage(video, 0, 0, width, height);
          var data = canvas.toDataURL('image/jpeg', 0.3);
          // Logger(LOG_LEVEL.VERBOSE, data);
          return data;
        } else {
          clearCanvas();
          return;
        }
      }
    });
  };

  /**
   * @private
   * @memberOf OTProctor
   * @description sends base64image to backend
   * */
  sendSnapshotToBackend = (uid,tid,tkn,picture)=>{
    return new Promise(function(resolve, reject) {
      Logger(LOG_LEVEL.INFO,'sendSnapshotToBackend called');
      if (!picture) {
        reject(false);
      }
      let studentId = uid?uid: currUser.userId;
      let testId= tid?tid: currUser.testId;
      let token = tkn? tkn: currUser.token;
      fetch(`${API_URL}/api/snapshot/${studentId}/${testId}`, {
        method: 'post',
        headers: {
          'Accept': 'application/json, text/plain, */*',
          'Content-Type': 'application/json',
          'Authorization': 'Bearer '+token
        },
        body: JSON.stringify({
          'base64image':picture
        })
      })
      .then((data)=>{
        if (data.status === 201) {
          Logger(LOG_LEVEL.INFO, 'Stored snapshot')
          Logger(LOG_LEVEL.DEBUG, `${data.status} ${data.statusText}` )
          resolve(true);
        } else {
          Logger(LOG_LEVEL.INFO, 'Storing failed')
          Logger(LOG_LEVEL.DEBUG, `${data.status} ${data.statusText}` )
          reject(data.statusText)
        }
      })
      .catch((err)=>{
        //cant send to backend
        Logger(LOG_LEVEL.ERROR, 'Unable to store snapshot' + err)
        reject(false);
      });
    });
  };

  /**
   * @public
   * @instance
   * @memberOf OTProctor
   * @method stopPeriodicSnapshot
   * @description stops the periodic capture of snapshots and releases camera
   *
   * @returns {Boolean} True if successfully stop the snapshot else false
   */
  this.stopPeriodicSnapshot = () => {
    Logger(LOG_LEVEL.INFO,'StopSnapshot called');
    if (!snapshotIntervalRef && !snapshotMediastreamRef) {
      return false;
    }

    if (snapshotIntervalRef) {
      window.clearInterval(snapshotIntervalRef);
      Logger(LOG_LEVEL.INFO, 'cleared interval');
    }

    if (snapshotMediastreamRef) {
      let tracks = snapshotMediastreamRef.getTracks();
      tracks.forEach((track) => {
        track.stop();
      });
      Logger(LOG_LEVEL.INFO, 'cleared snapshotMediastreamRef');
      return true;
    };
    return false;
  };

  /**
   * @typedef Snapshot
   * @property {string} uri The s3 url of the snapshot
   * @property {string} timestamp The unix timestamp for the snapshot
   *
   * @example
   *  {
   *   uri: “s3:/arn/us-east/bucket/procto/1590225414.png”
   *   timestamp: “1590225414”
   * }
   */

  /**
   * @public
   * @instance
   * @memberOf OTProctor
   * @method fetchSnapshots
   * @description fetches array of snapshots for a particular user, test
   * @param {string} sid - userid for the student
   * @param {string} tid - testId for the current session
   * @param {string} [pid=currUser.userId] - userId for the current proctor, defaults to the userId set in initialize
   * @param {string} [token=currUser.token] - token for the current session, defaults to the token set in initialize if passed null
   *
   * @returns {Promise.Array<Snapshot>} A promise object that resolves to a list of snapshots or rejects with error
   *
   */
   this.fetchSnapshots = (sid, tid, pid, token) => {
     return new Promise(function(resolve, reject) {

       let studentId = sid;
       let testId= tid;
       if (!studentId || !testId) {
         reject('Insufficient argument')
       };

       let proctorId = pid? pid: currUser.userId;
       let currtoken = token? token: currUser.token;

       fetch(`${API_URL}/api/snapshot?userid=${studentId}&testid=${testId}&proctorid=${proctorId}`,{
         method: 'get',
         mode: 'cors',
         headers: {
           'Authorization': 'Bearer '+currtoken
         }
       })
       .then((data)=>{
         Logger(LOG_LEVEL.DEBUG, data);
         if (data.status === 200) {
           let res = data.json();
           res.then((resdata)=>{
             Logger(LOG_LEVEL.INFO,'Fetching snapshot successful');
             resolve(resdata.snapshots);
           });
         } else if(data.status === 404) {
           //sending empty array as no snapshot found
           resolve([]);
         } else {
           let res = data.text();
           res.then((errdata)=>{
             Logger(LOG_LEVEL.INFO,'Fetching snapshot failed');
             reject(errdata)
           });
         }
       })
       .catch((err)=>{
         Logger(LOG_LEVEL.ERROR,'Error in fetching snapshot');
         reject(err);
       });
     });
   };

  /**
   * @typedef Videos
   * @property {string} url The url of the recorded video. The name follows the format USER)D_TEST_ID_DATE_SEQ.webm
   *
   * @example
   * "123_1_2020-05-20_0.webm"
   */

  /**
   * @public
   * @instance
   * @memberOf OTProctor
   * @method fetchAllVideosOfAuser
   * @description Fetch all video of a user for a particular test id
   * @param {string} sid - Student's User Id
   * @param {string} tid - Test Id
   * @param {string} [pid=currUser.userId] - Proctor Id defaults to userId set during initialize
   * @param {string} [token=currUser.token] - Token for the request, defaults to the token set during initialize
   * @returns {Promise.Array<Videos>} A promise object that resolves with an array of video files or rejects with error
   *
   */
  this.fetchAllVideosOfAuser = ( sid, tid, pid, token) => {
    Logger(LOG_LEVEL.INFO, 'fetchAllVideosOfAuser called');
    return new Promise((resolve, reject)=>{
      let studentId = sid;
      let testId = tid;
      if (!studentId || !testId) {
        return reject('Insufficient argument')
      };
      let proctorId = pid || currUser.userId;
      let currToken = token? token: currUser.token;

      fetch(`${API_URL}/api/getUserRecordings?userid=${studentId}&testid=${testId}&proctorid=${proctorId}`, {
        method: 'get',
        headers: {
          'Accept': 'application/json, text/plain, */*',
          'Content-Type': 'application/json',
          'Authorization': 'Bearer '+currToken
        }
      })
      .then((data)=>{
        Logger(LOG_LEVEL.DEBUG, data);
        if (data.status === 200) {
          let res = data.json();
          res.then((resdata)=>{
            Logger(LOG_LEVEL.INFO, 'getUserRecordings success.');
            Logger(LOG_LEVEL.DEBUG, JSON.stringify(resdata));
            return resolve(resdata.files);
          });
        } else {
          let res = data.text();
          res.then((errdata)=>{
            Logger(LOG_LEVEL.ERROR, errdata);
            return reject(errdata);
          })
        }
      })
      .catch((err)=>{
        Logger(LOG_LEVEL.ERROR, err);
        return reject(err)
      });
    });
  };

  let onPlayOffer = (file, proctorId, token, errorCallback) => {
    Logger(LOG_LEVEL.INFO,"onPlayOffercalled");
    //expecting filename as userId_testId_date_seq.webm
    let splitFile = file.split('_');
    if (splitFile.length<4) {
      return onError("error in file name");
    }

    let userId = splitFile[0];
    let testId = splitFile[1];
    return function _onPlayOffer(error, offerSdp) {
      if(error) {
        if(errorCallback) errorCallback();
        return onError(error);
      }
      Logger(LOG_LEVEL.DEBUG,'Invoking onPlayOffer callback function ' + location.host);
      recordedPlayErrorCallback = errorCallback;
      let message = {
    		id : 'play',
        sdpOffer : offerSdp,
        userId: userId,
        testId: testId,
        proctorId: proctorId,
        file: file,
        token: token
      };
      sendMessage(message);
    }
  };

  let onLiveOffer = (userId, testId, proctorId, token, errorCallback) => {
    Logger(LOG_LEVEL.INFO,"onLiveOffer called");
    Logger(LOG_LEVEL.DEBUG," "+ userId+" "+ proctorId+" "+ testId);
    return function onLiveOfferInternal(error, offerSdp) {
      if(error) {
        if(errorCallback) errorCallback();
        return onError(error);
      }
      Logger(LOG_LEVEL.DEBUG, 'Invoking onLiveOffer callback' + location.host);
      livePlayErrorCallback = errorCallback;
    	var message = {
    		id : 'live',
        sdpOffer : offerSdp,
        userId: userId,
        testId: testId,
        proctorId: proctorId,
        token: token
    	};
    	sendMessage(message);
    };
  };

  /**
   * @public
   * @instance
   * @memberOf OTProctor
   * @method fetchVideoStream
   * @description Fetch a video stream
   * @param {enum} type - LIVE, RECORDED
   * @param {string} videoElementId - HTML Element ID where you want to render the video
   * @param {string} [errorCallback] - Function to be called if there is some error, pass null otherwise
   * @param {string} [successCallback] - Function to be called once stream is started, pass null otherwise
   * @param {string} [streamEndCallback] - Function to be called once recorded stream playback completes, pass null otherwise
   * @param {string} [videoName] - Name of the video, required for RECOREDED type only, pass null otherwise
   * @param {string} userId - userId
   * @param {string} testId - testId
   * @returns {Promise} Resolves to true if able to open socket and invoke fetchVideo else false
   */
  this.fetchVideoStream = (type, videoElementId, errorCallback, successCallback, streamEndCallback, videoName, userId, testId) => {
    return new Promise(function(resolve, reject) {
      checkSocketPipe('fetch_videostream')
      .then((data)=>{
        return fetchTurnCred(userId, testId, currUser.userId, currUser.token, turnClient, null)
      })
      .then((turnCred) => {
        _fetchVideoStream(turnCred, type, videoElementId, errorCallback, successCallback, streamEndCallback, videoName, userId, testId);
        return resolve(true);
      })
      .catch((err) => {
        return reject(err)
      });
    });
  };

  _fetchVideoStream = (turnCred, type, videoElementId, errorCallback, successCallback, streamEndCallback, videoName, userId, testId) => {
    Logger(LOG_LEVEL.DEBUG, 'fetchVideoStream..'+ type + videoElementId + videoName + userId + testId);
    Logger(LOG_LEVEL.DEBUG, videoElementId);
    let videoInput = document.getElementById(videoElementId);
  	setState(STATE.PLAYING);
  	Logger(LOG_LEVEL.INFO, 'Creating webRtcPeer for fetchVideoStream offer');

    let turnServersWithAuth = getTurnWithAuth(turnServers, turnCred);
    let options = {
      localVideo: videoInput,
      remoteVideo: videoInput,
      onicecandidate : onIceCandidate,
    };
    // if turnServers is null then use freeice
    if (turnServersWithAuth) {
      options.configuration = {
        iceServers: turnServersWithAuth
      }
    }
    Logger(LOG_LEVEL.DEBUG, options);

    webRtcPeer = kurentoUtils.WebRtcPeer.WebRtcPeerRecvonly(options, function(error) {
        if(error) {
          if (errorCallback) {
            errorCallback();
          }
          return onError(error);
        } else {
          videoStreamSuccessCallback =  successCallback;
          if (type !== "LIVE") {
            Logger(LOG_LEVEL.INFO, 'RECOREDED video playback requested');
            Logger(LOG_LEVEL.INFO, videoName);
            let onPlay = onPlayOffer(videoName, currUser.userId, currUser.token, errorCallback);
            recordedStreamEndCallback =  streamEndCallback;
            this.generateOffer(onPlay);
          } else {
            Logger(LOG_LEVEL.INFO, 'LIVE video playback requested')
            let onLive = onLiveOffer(userId, testId, currUser.userId, currUser.token, errorCallback);
            this.generateOffer(onLive);
          }
        }
    });
  };

  /**
   * @public
   * @instance
   * @memberOf OTProctor
   * @method seekVideo
   * @description Seek video ahead or back in seconds
   * @param {string} userId - userId
   * @param {string} testId - testId
   * @param {number} secondsToJump - Number of seconds to jump +ve for moving forward, -ve for moving back
   * @param {string} [proctorId=currUser.userId] - Proctor Id, defaults to userid set at initialize
   * @param {string} [token=currUser.token] - Bearer token defaults to token set at initialize
   * @param {string} [successCallback] - Function to be called on successful seeking
   * @param {string} [errorCallback] - Function to be called on error in seeking
   * @returns {Promise} Resolves to true if able to open socket and invoke seekVideo else false.
   * Calls the successCallback after adjusting the video position
   */
  this.seekVideo = (userId, testId, secondsToJump, proctorId, token, successCallback, errorCallback) => {
    return new Promise(function(resolve, reject) {
      checkSocketPipe('seek_video')
      .then(() => {
        if (webRtcPeer) {
          let message = {
            id : 'seek',
            seconds: secondsToJump,
            userId: userId,
            testId: testId,
            proctorId: proctorId || currUser.userId,
            token: token || currUser.token
          };
          seekAckSuccessCallback = successCallback;
          seekErrorCallback = errorCallback;
          sendMessage(message);
          resolve(true);
        } else {
          //no webRtcPeer exists
          reject(false);
          errorCallback('Now webRtcPeer connection exists');
        }
      })
      .catch((err)=>{
        // error opening socket
        reject(err)
        errorCallback('Could not open socket');
      })
    });
  };

  /**
   * @public
   * @instance
   * @memberOf OTProctor
   * @method pauseVideo
   * @description Pause video
   * @param {string} userId - userId
   * @param {string} testId - testId
   * @param {string} [proctorId=currUser.userId] - Proctor Id, defaults to userid set at initialize
   * @param {string} [token=currUser.token] - Bearer token defaults to token set at initialize
   * @param {string} [successCallback] - Function to be called on successful pause
   * @param {string} [errorCallback] - Function to be called on error in pause
   * @returns {Promise} Resolves to true if able to open socket and invoke pause else false.
   * Calls the successCallback after pausing the video
   */
  this.pauseVideo = (userId, testId, proctorId, token, successCallback, errorCallback) => {
    return new Promise(function(resolve, reject) {
      checkSocketPipe('pauseVideo')
      .then(() => {
        if (webRtcPeer) {
          let message = {
            id: "pause",
            userId: userId,
            testId: testId,
            proctorId: proctorId || currUser.userId,
            token: token || currUser.token
          };
          pauseAckSuccessCallback = successCallback;
          pauseErrorCallback = errorCallback;
          sendMessage(message);
          resolve(true);
        } else {
          //no webRtcPeer exists
          reject(false);
          errorCallback('No webRtcPeer connection exists');
        }
      })
      .catch((err)=>{
        // error opening socket
        reject(err)
        errorCallback('Could not open socket');
      })
    });
  };


  /**
   * @public
   * @instance
   * @memberOf OTProctor
   * @method resumeVideo
   * @description Resume video
   * @param {string} userId - userId
   * @param {string} testId - testId
   * @param {string} [proctorId=currUser.userId] - Proctor Id, defaults to userid set at initialize
   * @param {string} [token=currUser.token] - Bearer token defaults to token set at initialize
   * @param {string} [successCallback] - Function to be called on successful pause
   * @param {string} [errorCallback] - Function to be called on error in pause
   * @returns {Promise} Resolves to true if able to open socket and invoke resume else false.
   * Calls the successCallback after resuming the video
   */
  this.resumeVideo = (userId, testId, proctorId, token, successCallback, errorCallback) => {
    return new Promise(function(resolve, reject) {
      checkSocketPipe('resumeVideo')
      .then(() => {
        if (webRtcPeer) {
          let message = {
            id: "resume",
            userId: userId,
            testId: testId,
            proctorId: proctorId || currUser.userId,
            token: token || currUser.token
          };
          resumeAckSuccessCallback = successCallback;
          resumeErrorCallback = errorCallback;
          sendMessage(message);
          resolve(true);
        } else {
          //no webRtcPeer exists
          reject(false);
          errorCallback('No video reference exists');
        }
      })
      .catch((err)=>{
        // error opening socket
        reject(err)
        errorCallback('Could not open socket');
      })
    });
  };

  /**
   * @typedef Students
   * @property {string} sessionId a string representing the sessioin
   * @property {string} userId The user id bound to the session
   * @property {string} testId The test id for the session
   * @property {string} snapshot The URL of snapshot
   * @property {timestamp} snapshotTime The unix timestamp
   *
   * @example
   *
   * {
   * "sessionId":"LJwFvTRb77_uzijrKZfYNlkYQE_Y1Qs0",
   * "userId":"123",
   * "testId":"1",
   * "snapshot":"123_1_2020-05-21_0.webm",
   * "snapshotTime":"1590039532829",
   * "timestamp":"1590039532829"
   * }
   */

  /**
   * @public
   * @instance
   * @memberOf OTProctor
   * @method fetchAllLiveStudents
   * @description Fetch all students livestreaming at the moment for a particular testId
   * @param {string} [testId=currUser.testId] - Test Id, defaults to testid set at initialize
   * @param {string} [proctorId=currUser.userId] - Proctor Id, defaults to userid set at initialize
   * @param {string} [tkn=currUser.token] - Bearer token defaults to token set at initialize
   * @returns {Promise.Array<Students>} A promise object that resolves with an array of live students description
   *
   */
  this.fetchAllLiveStudents = (tid, pid, tkn) => {

    Logger(LOG_LEVEL.INFO,'fetchAllLiveStudents called');

    return new Promise((resolve, reject)=>{
      let testId= tid?tid: currUser.testId;
      let proctorId = pid?pid: currUser.userId;
      let token = tkn?tkn: currUser.token;
      if (!testId || !proctorId || !token) {
        Logger(LOG_LEVEL.ERROR, 'Insufficient Arguments.');
        return reject('Insufficient Argument');
      }
      fetch(`${API_URL}/api/getLiveSessions?testid=${testId}&proctorid=${proctorId}`,{
        method: 'get',
        headers: {
          'Authorization': 'Bearer '+token
        }
      })
      .then((data)=>{
        Logger(LOG_LEVEL.DEBUG, data);
        if (data.status === 200) {
          let res = data.json();
          res.then((resdata)=>{
            Logger(LOG_LEVEL.INFO, 'fetchAllLiveStudents success.');
            Logger(LOG_LEVEL.DEBUG, JSON.stringify(resdata));
            return resolve(resdata.sessions);
          });
        } else {
          let res = data.text();
          res.then((errdata)=>{
            Logger(LOG_LEVEL.ERROR,'errdata is '+ errdata);
            return reject(errdata);
          });
        }
      })
      .catch((err)=>{
        Logger(LOG_LEVEL.ERROR, JSON.stringify(err));
        return reject(err);
      });
    });
  };

  /**
   * @public
   * @instance
   * @memberOf OTProctor
   * @method isStudentLive
   * @description Returns true if student is live, false otherwise
   * @param {string} sid - Student Id
   * @param {string} [testId=currUser.testId] - Test Id, defaults to testid set at initialize
   * @param {string} [proctorId=currUser.userId] - Proctor Id, defaults to userid set at initialize
   * @param {string} [tkn=currUser.token] - Bearer token defaults to token set at initialize
   * @returns {Promise.Boolean} A promise object that resolves with true if student is live, false if not or reject with error
   *
   */
  this.isStudentLive = (sid, tid, pid, tkn) => {

    Logger(LOG_LEVEL.INFO,'isStudentLive called');

    return new Promise((resolve, reject)=>{
      let testId= tid?tid: currUser.testId;
      let proctorId = pid?pid: currUser.userId;
      let token = tkn?tkn: currUser.token;
      if (!sid || !testId || !proctorId || !token) {
        Logger(LOG_LEVEL.ERROR, 'Insufficient Arguments.');
        return reject('Insufficient Argument');
      }
      fetch(`${API_URL}/api/getLiveSessions?testid=${testId}&proctorid=${proctorId}&userid=${sid}`,{
        method: 'get',
        headers: {
          'Authorization': 'Bearer '+token
        }
      })
      .then((data)=>{
        console.log('got data', data);
        Logger(LOG_LEVEL.DEBUG, data);
        if (data.status === 200) {
          let res = data.json();
          res.then((resdata)=>{
            Logger(LOG_LEVEL.INFO, 'isStudentLive success.');
            Logger(LOG_LEVEL.DEBUG, JSON.stringify(resdata));
            if (resdata && resdata.sessions && resdata.sessions.length>0) {
              return resolve(true);
            }
            return resolve(false);
          });
        } else {
          let res = data.text();
          res.then((errdata)=>{
            Logger(LOG_LEVEL.ERROR,'errdata is '+ errdata);
            return reject(errdata);
          });
        }
      })
      .catch((err)=>{
        Logger(LOG_LEVEL.ERROR, JSON.stringify(err));
        return reject(err);
      });
    });
  };

  /****Utility**/
  /**
   * Returns date in YYYY-MM-DD format
   */
  getFormattedDate = function getFormattedDate(cdate) {
     let d = cdate?cdate:new Date();
     let cmonth = d.getMonth()+1;
     if(cmonth<10) cmonth = "0"+cmonth;
     return d.getFullYear() + "-" + cmonth + "-" + d.getDate();
   }

  this.getLog = function () {
     return logContent;
   }
}